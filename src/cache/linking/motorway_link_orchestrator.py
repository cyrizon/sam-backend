"""
Motorway Link Orchestrator
--------------------------

Orchestrates the complete motorway link building process:
1. Chains indeterminate segments
2. Links entries to chains
3. Links chains to exits
4. Outputs orphaned segments to JSON
"""

import json
import os
from typing import List, Dict, Set, Tuple, Optional
from dataclasses import asdict

from ..models.motorway_link import MotorwayLink
from ..models.complete_motorway_link import CompleteMotorwayLink
from ..models.link_types import LinkType
from .coordinate_matcher import SegmentConnectionAnalyzer, are_coordinates_equal
from .coordinate_chain_builder import CoordinateChainBuilder, CoordinateChain


class MotorwayLinkOrchestrator:
    """Orchestrateur principal pour la construction des liens complets."""
    
    def __init__(self, max_distance_m: float = 2.0, output_dir: str = None):
        """
        Initialise l'orchestrateur.
        
        Args:
            max_distance_m: Distance maximale pour lier deux segments (ignor√© maintenant)
            output_dir: R√©pertoire de sortie pour les orphelins. Si None, utilise CACHE_DIR depuis l'environnement
        """
        # Utiliser la variable d'environnement si output_dir n'est pas fourni
        if output_dir is None:
            output_dir = os.getenv("CACHE_DIR", "./osm_cache_test")
            
        self.analyzer = SegmentConnectionAnalyzer(max_distance_m)
        self.chain_builder = CoordinateChainBuilder()
        self.output_dir = output_dir
        self.max_distance_m = max_distance_m
    
    def build_complete_links(
        self,
        entries: List[MotorwayLink],
        exits: List[MotorwayLink],
        indeterminates: List[MotorwayLink]
    ) -> Tuple[List[CompleteMotorwayLink], Dict[str, any]]:
        """
        Construit les liens complets √† partir des segments d'entr√©e, sortie et ind√©termin√©s.
        
        Args:
            entries: Segments d'entr√©e
            exits: Segments de sortie
            indeterminates: Segments ind√©termin√©s
            
        Returns:
            Tuple[liens_complets, statistiques]
        """
        print("üèóÔ∏è  D√©but de la construction des liens complets...")
        print(f"   ‚Ä¢ Entr√©es: {len(entries)}")
        print(f"   ‚Ä¢ Sorties: {len(exits)}")
        print(f"   ‚Ä¢ Ind√©termin√©s: {len(indeterminates)}")
        
        # √âtape 1: Cha√Æner les segments ind√©termin√©s
        print("\nüîó √âtape 1: Construction des cha√Ænes de segments ind√©termin√©s")
        chain_result = self.chain_builder.build_chains(indeterminates)
        
        # √âtape 2: Lier les entr√©es aux cha√Ænes SEULEMENT
        print("üîó √âtape 2: Liaison des entr√©es aux cha√Ænes")
        entry_links, used_chains_entry = self._link_entries_to_chains(
            entries, chain_result.chains
        )
        
        # √âtape 3: Lier les sorties aux cha√Ænes restantes
        print("üîó √âtape 3: Liaison des sorties aux cha√Ænes restantes")
        exit_links, used_chains_exit = self._link_exits_to_chains(
            exits, chain_result.chains, used_chains_entry
        )
        
        # √âtape 4: Cr√©er des liens simples pour les segments non li√©s
        print("üîó √âtape 4: Cr√©ation de liens simples pour les segments isol√©s")
        simple_links = self._create_simple_links(
            entries, exits, entry_links, exit_links
        )
        
        # Collecter tous les liens complets
        all_complete_links = entry_links + exit_links + simple_links
        
        # √âtape 5: G√©rer les orphelins
        print("üóÇÔ∏è  √âtape 5: Gestion des segments orphelins")
        used_chains_all = used_chains_entry | used_chains_exit
        orphaned_data = self._handle_orphaned_segments(
            chain_result, used_chains_all
        )
        
        # Statistiques finales
        stats = self._generate_final_statistics(
            entries, exits, indeterminates, all_complete_links, orphaned_data
        )
        
        self._print_final_summary(stats)
        
        return all_complete_links, stats
    
    def _link_entries_to_chains(
        self,
        entries: List[MotorwayLink],
        chains: List[CoordinateChain]
    ) -> Tuple[List[CompleteMotorwayLink], Set[str]]:
        """
        Lie les entr√©es aux cha√Ænes SEULEMENT.
        Logique: entry_start -> chain_end (d√©but de l'entr√©e = fin de la cha√Æne)
        
        Returns:
            Tuple[liens_cr√©√©s, cha√Ænes_utilis√©es]
        """
        entry_links = []
        used_chains = set()
        
        for entry in entries:
            # Chercher une cha√Æne qui finit o√π l'entr√©e commence
            linked_chain = self._find_chain_for_entry(entry, chains, used_chains)
            
            if linked_chain:
                # Cr√©er le lien complet : [CHA√éNE] + [ENTR√âE]
                # Car on vient de la cha√Æne vers l'entr√©e
                segments = linked_chain.segments + [entry]
                
                complete_link = CompleteMotorwayLink(
                    link_id=f"entry_link_{entry.way_id}",
                    link_type=LinkType.ENTRY,
                    segments=segments,
                    destination=entry.destination
                )
                
                entry_links.append(complete_link)
                used_chains.add(linked_chain.chain_id)
        
        print(f"   ‚Ä¢ Liens d'entr√©e cr√©√©s: {len(entry_links)}")
        return entry_links, used_chains

    def _link_exits_to_chains(
        self,
        exits: List[MotorwayLink],
        chains: List[CoordinateChain],
        used_chains: Set[str]
    ) -> Tuple[List[CompleteMotorwayLink], Set[str]]:
        """
        Lie les sorties aux cha√Ænes restantes SEULEMENT.
        Logique: chain_start -> exit_end (d√©but de la cha√Æne = fin de la sortie)
        
        Returns:
            Tuple[liens_cr√©√©s, nouvelles_cha√Ænes_utilis√©es]
        """
        exit_links = []
        newly_used_chains = set()
        
        # Cha√Ænes disponibles (non utilis√©es par les entr√©es)
        available_chains = [c for c in chains if c.chain_id not in used_chains]
        
        for exit in exits:
            # Chercher une cha√Æne qui commence o√π la sortie finit
            linked_chain = self._find_chain_for_exit(exit, available_chains, newly_used_chains)
            
            if linked_chain:
                # Cr√©er le lien complet : [SORTIE] + [CHA√éNE]
                # Car on va de la sortie vers la cha√Æne
                segments = [exit] + linked_chain.segments
                
                complete_link = CompleteMotorwayLink(
                    link_id=f"exit_link_{exit.way_id}",
                    link_type=LinkType.EXIT,
                    segments=segments,
                    destination=exit.destination
                )
                
                exit_links.append(complete_link)
                newly_used_chains.add(linked_chain.chain_id)
        
        print(f"   ‚Ä¢ Liens de sortie cr√©√©s: {len(exit_links)}")
        return exit_links, newly_used_chains
    
    def _create_simple_links(
        self,
        entries: List[MotorwayLink],
        exits: List[MotorwayLink],
        entry_links: List[CompleteMotorwayLink],
        exit_links: List[CompleteMotorwayLink]
    ) -> List[CompleteMotorwayLink]:
        """Cr√©e des liens simples pour les segments isol√©s."""
        simple_links = []
        
        # Entr√©es utilis√©es dans les liens d'entr√©e (maintenant c'est le dernier segment)
        used_entries = {link.segments[-1].way_id for link in entry_links}
        
        # Sorties utilis√©es dans les liens de sortie (maintenant c'est le premier segment)
        used_exits_in_exit_links = {link.segments[0].way_id for link in exit_links}
        
        # Cr√©er des liens simples pour les entr√©es non utilis√©es
        for entry in entries:
            if entry.way_id not in used_entries:
                simple_link = CompleteMotorwayLink(
                    link_id=f"entry_direct_{entry.way_id}",
                    link_type=LinkType.ENTRY,
                    segments=[entry],
                    destination=entry.destination
                )
                simple_links.append(simple_link)
        
        # Cr√©er des liens simples pour les sorties non utilis√©es
        for exit in exits:
            if exit.way_id not in used_exits_in_exit_links:
                simple_link = CompleteMotorwayLink(
                    link_id=f"exit_direct_{exit.way_id}",
                    link_type=LinkType.EXIT,
                    segments=[exit],
                    destination=exit.destination
                )
                simple_links.append(simple_link)
        
        print(f"   ‚Ä¢ Liens simples cr√©√©s: {len(simple_links)}")
        return simple_links
    
    def _find_chain_for_entry(
        self,
        entry: MotorwayLink,
        chains: List[CoordinateChain],
        used_chains: Set[str]
    ) -> Optional[CoordinateChain]:
        """
        Trouve une cha√Æne pour une entr√©e.
        Logique: entry_start -> chain_end (d√©but de l'entr√©e = fin de la cha√Æne)
        """
        for chain in chains:
            if chain.chain_id in used_chains:
                continue
            
            # Test connexion : d√©but de l'entr√©e = fin de la cha√Æne
            if are_coordinates_equal(entry.get_start_point(), chain.get_end_point()):
                return chain
        
        return None
    
    def _find_chain_for_exit(
        self,
        exit: MotorwayLink,
        chains: List[CoordinateChain],
        used_chains: Set[str]
    ) -> Optional[CoordinateChain]:
        """
        Trouve une cha√Æne pour une sortie.
        Logique: chain_start -> exit_end (d√©but de la cha√Æne = fin de la sortie)
        """
        for chain in chains:
            if chain.chain_id in used_chains:
                continue
            
            # Test connexion : d√©but de la cha√Æne = fin de la sortie
            if are_coordinates_equal(chain.get_start_point(), exit.get_end_point()):
                return chain
        
        return None
    
    def _handle_orphaned_segments(
        self,
        chain_result,
        used_chains: Set[str]
    ) -> Dict[str, any]:
        """G√®re les segments orphelins et les sauvegarde en JSON."""
        unused_chains = [
            chain for chain in chain_result.chains
            if chain.chain_id not in used_chains
        ]
        
        orphaned_data = {
            "unused_chains": [],
            "orphaned_individual_segments": []
        }
        
        # Cha√Ænes non utilis√©es
        for chain in unused_chains:
            chain_data = {
                "chain_id": chain.chain_id,
                "segment_count": chain.get_segment_count(),
                "segments": [
                    {
                        "way_id": seg.way_id,
                        "coordinates": seg.coordinates,
                        "properties": seg.properties
                    }
                    for seg in chain.segments
                ]
            }
            orphaned_data["unused_chains"].append(chain_data)
        
        # Segments individuels orphelins
        for segment in chain_result.orphaned_segments:
            segment_data = {
                "way_id": segment.way_id,
                "coordinates": segment.coordinates,
                "properties": segment.properties
            }
            orphaned_data["orphaned_individual_segments"].append(segment_data)
        
        # Sauvegarder en JSON
        self._save_orphaned_segments(orphaned_data)
        
        return orphaned_data
    
    def _save_orphaned_segments(self, orphaned_data: Dict[str, any]):
        """Sauvegarde les segments orphelins en JSON."""
        output_file = os.path.join(self.output_dir, "orphaned_segments.json")
        
        # Cr√©er le r√©pertoire si n√©cessaire
        os.makedirs(self.output_dir, exist_ok=True)
        
        try:
            with open(output_file, 'w', encoding='utf-8') as f:
                json.dump(orphaned_data, f, indent=2, ensure_ascii=False)
            
            print(f"   ‚Ä¢ Segments orphelins sauvegard√©s: {output_file}")
        except Exception as e:
            print(f"   ‚ö†Ô∏è  Erreur lors de la sauvegarde des orphelins: {e}")
    
    def _generate_final_statistics(
        self,
        entries: List[MotorwayLink],
        exits: List[MotorwayLink],
        indeterminates: List[MotorwayLink],
        complete_links: List[CompleteMotorwayLink],
        orphaned_data: Dict[str, any]
    ) -> Dict[str, any]:
        """G√©n√®re les statistiques finales."""
        return {
            "input_segments": {
                "entries": len(entries),
                "exits": len(exits),
                "indeterminates": len(indeterminates),
                "total": len(entries) + len(exits) + len(indeterminates)
            },
            "output_links": {
                "complete_links": len(complete_links),
                "entry_links": len([l for l in complete_links if l.link_type == LinkType.ENTRY]),
                "exit_links": len([l for l in complete_links if l.link_type == LinkType.EXIT])
            },
            "orphaned": {
                "unused_chains": len(orphaned_data["unused_chains"]),
                "orphaned_segments": len(orphaned_data["orphaned_individual_segments"])
            },
            "linking_efficiency": {
                "segments_in_complete_links": sum(len(link.segments) for link in complete_links),
                "usage_percentage": round(
                    (sum(len(link.segments) for link in complete_links) / 
                     (len(entries) + len(exits) + len(indeterminates))) * 100, 2
                )
            }
        }
    
    def _print_final_summary(self, stats: Dict[str, any]):
        """Affiche le r√©sum√© final."""
        print(f"\nüìä R√âSUM√â FINAL DE LA CONSTRUCTION DES LIENS")
        print(f"‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê")
        print(f"üì• Segments d'entr√©e:")
        print(f"   ‚Ä¢ Entr√©es: {stats['input_segments']['entries']}")
        print(f"   ‚Ä¢ Sorties: {stats['input_segments']['exits']}")
        print(f"   ‚Ä¢ Ind√©termin√©s: {stats['input_segments']['indeterminates']}")
        print(f"   ‚Ä¢ Total: {stats['input_segments']['total']}")
        
        print(f"\nüì§ Liens complets cr√©√©s:")
        print(f"   ‚Ä¢ Liens d'entr√©e: {stats['output_links']['entry_links']}")
        print(f"   ‚Ä¢ Liens de sortie: {stats['output_links']['exit_links']}")
        print(f"   ‚Ä¢ Total: {stats['output_links']['complete_links']}")
        
        print(f"\nüóÇÔ∏è  Segments orphelins:")
        print(f"   ‚Ä¢ Cha√Ænes non utilis√©es: {stats['orphaned']['unused_chains']}")
        print(f"   ‚Ä¢ Segments individuels: {stats['orphaned']['orphaned_segments']}")
        
        print(f"\n‚ö° Efficacit√© de liaison:")
        print(f"   ‚Ä¢ Segments utilis√©s: {stats['linking_efficiency']['segments_in_complete_links']}")
        print(f"   ‚Ä¢ Pourcentage d'utilisation: {stats['linking_efficiency']['usage_percentage']}%")
        
        print(f"\n‚úÖ Construction des liens complets termin√©e!\n")
