"""
segment_builders.py
------------------

Module pour les m√©thodes de construction de segments sp√©cialis√©s.
Responsabilit√© : cr√©er diff√©rents types de segments selon les contextes sp√©cifiques.
"""

from typing import List, Dict
from src.cache.models.matched_toll import MatchedToll
from .toll_positioning import TollPositioning
from .exit_finder import ExitFinder


class SegmentBuilders:
    """
    Collection de m√©thodes pour construire des segments sp√©cialis√©s.
    """
    
    def __init__(self, entrance_exit_finder, junction_analyzer=None):
        """
        Initialise les builders avec les outils n√©cessaires.
        
        Args:
            entrance_exit_finder: Finder pour les entr√©es/sorties
            junction_analyzer: Analyzer pour les junctions (optionnel)
        """
        self.entrance_exit_finder = entrance_exit_finder
        self.junction_analyzer = junction_analyzer
        self.toll_positioning = TollPositioning()
        self.exit_finder = ExitFinder(entrance_exit_finder, junction_analyzer)
    
    def build_first_segment(
        self, 
        start_coords: List[float], 
        first_toll: MatchedToll,
        all_tolls: List[MatchedToll],
        route_coords: List[List[float]] = None
    ) -> Dict:
        """
        Construit le premier segment : d√©part ‚Üí premier p√©age.
        Utilise les vraies motorway_junctions pour √©viter les p√©ages pr√©c√©dents.
        
        Args:
            start_coords: Coordonn√©es de d√©part
            first_toll: Premier p√©age s√©lectionn√©
            all_tolls: Tous les p√©ages sur la route
            route_coords: Coordonn√©es de la route de base
            
        Returns:
            Dict: Segment de route
        """        
        # V√©rifier s'il y a des p√©ages √† √©viter avant le premier p√©age
        tolls_before = self.toll_positioning.get_tolls_before(first_toll, all_tolls)
        
        if tolls_before and self.junction_analyzer and route_coords:
            # Utiliser l'analyzer pour trouver la vraie sortie avant le premier p√©age
            exit_junction = self.junction_analyzer.find_exit_before_toll(
                route_coords, first_toll, tolls_before
            )
            
            if exit_junction:
                # Quand on trouve une sortie, on va directement √† l'entr√©e du p√©age s√©lectionn√©
                # pour √©viter les segments manquants
                entrance_coords = self.entrance_exit_finder.find_entrance_coordinates(first_toll)
                segment_type = 'avoid_tolls'
                end_coords = entrance_coords
                print(f"   üìç Segment 1 : D√©part ‚Üí Entr√©e {first_toll.effective_name} (√©vite {len(tolls_before)} p√©ages via sortie {exit_junction['name']})")
                
                # Stocker la sortie optimale pour utilisation ult√©rieure si n√©cessaire
                setattr(self, '_exit_before_first_toll', exit_junction)
            else:
                # Fallback vers la m√©thode classique
                entrance_coords = self.entrance_exit_finder.find_entrance_coordinates(first_toll)
                segment_type = 'avoid_tolls'
                end_coords = entrance_coords
                print(f"   üìç Segment 1 : D√©part ‚Üí Entr√©e {first_toll.effective_name} (√©vite {len(tolls_before)} p√©ages - fallback)")
        else:
            # Route normale jusqu'au p√©age
            segment_type = 'normal'
            end_coords = first_toll.osm_coordinates
            print(f"   üìç Segment 1 : D√©part ‚Üí {first_toll.effective_name} (route normale)")
        
        return {
            'segment_type': segment_type,
            'start': start_coords,
            'end': end_coords,
            'description': f"D√©part vers {first_toll.effective_name}"
        }
    
    def build_intermediate_segment(
        self, 
        previous_toll: MatchedToll, 
        current_toll: MatchedToll,
        all_tolls: List[MatchedToll]
    ) -> Dict:
        """
        Construit un segment interm√©diaire : p√©age pr√©c√©dent ‚Üí p√©age actuel.
        
        Args:
            previous_toll: P√©age pr√©c√©dent
            current_toll: P√©age actuel
            all_tolls: Tous les p√©ages sur la route
            
        Returns:
            Dict: Segment de route
        """
        # Trouver les p√©ages entre les deux p√©ages s√©lectionn√©s
        tolls_between = self.toll_positioning.get_tolls_between(previous_toll, current_toll, all_tolls)
        
        if tolls_between:
            # √âviter les p√©ages interm√©diaires : sortie pr√©c√©dent ‚Üí entr√©e actuel
            exit_coords = self.entrance_exit_finder.find_exit_coordinates(previous_toll)
            entrance_coords = self.entrance_exit_finder.find_entrance_coordinates(current_toll)
            
            segment_type = 'avoid_tolls'
            start_coords = exit_coords
            end_coords = entrance_coords
            print(f"   üìç Segment : Sortie {previous_toll.effective_name} ‚Üí Entr√©e {current_toll.effective_name} (√©vite {len(tolls_between)} p√©ages)")
        else:
            # Route normale entre les deux p√©ages
            segment_type = 'normal'
            start_coords = previous_toll.osm_coordinates
            end_coords = current_toll.osm_coordinates
            print(f"   üìç Segment : {previous_toll.effective_name} ‚Üí {current_toll.effective_name} (route normale)")
        
        return {
            'segment_type': segment_type,
            'start': start_coords,
            'end': end_coords,
            'description': f"{previous_toll.effective_name} vers {current_toll.effective_name}"
        }
    
    def build_last_segment(
        self, 
        last_toll: MatchedToll, 
        end_coords: List[float], 
        all_tolls: List[MatchedToll],
        route_coords: List[List[float]] = None
    ) -> Dict:
        """
        Construit le dernier segment : dernier p√©age ‚Üí arriv√©e.
        IMPORTANT : V√©rifie s'il y a des p√©ages √† √©viter APR√àS le dernier p√©age s√©lectionn√©.
        Utilise les vraies motorway_junctions pour trouver la sortie optimale.
        
        Args:
            last_toll: Dernier p√©age s√©lectionn√©
            end_coords: Coordonn√©es d'arriv√©e
            all_tolls: Tous les p√©ages sur la route (pour d√©tection des p√©ages √† √©viter)
            route_coords: Coordonn√©es de la route de base
            
        Returns:
            Dict: Segment de route
        """
        # V√©rifier s'il y a des p√©ages √† √©viter APR√àS le dernier p√©age s√©lectionn√©
        tolls_after = self.toll_positioning.get_tolls_after(last_toll, all_tolls)
        
        if tolls_after and self.junction_analyzer and route_coords:
            # Utiliser l'analyzer pour trouver la vraie sortie APR√àS le p√©age utilis√© et AVANT les p√©ages √† √©viter
            exit_junction = self.junction_analyzer.find_exit_after_toll(
                route_coords, last_toll, tolls_after
            )
            
            # V√©rifier si le p√©age est d√©j√† une sortie (exit_junction == None signifie p√©age d√©j√† sortie)
            if hasattr(last_toll, 'is_exit') and last_toll.is_exit and exit_junction is None:
                # Le p√©age est d√©j√† une sortie, aller directement √† la destination sans √©viter p√©ages
                segment_type = 'avoid_tolls'
                start_coords = last_toll.osm_coordinates
                description = f"{last_toll.effective_name} vers arriv√©e (d√©j√† une sortie)"
                print(f"   üìç Dernier segment : {last_toll.effective_name} ‚Üí Arriv√©e (p√©age d√©j√† sortie, √©vite {len(tolls_after)} p√©ages)")
            elif exit_junction:
                # Utiliser la sortie du p√©age s√©lectionn√© et router vers la sortie optimale
                exit_coords = self.entrance_exit_finder.find_exit_coordinates(last_toll)
                segment_type = 'avoid_tolls'
                start_coords = exit_coords
                description = f"Sortie {last_toll.effective_name} vers arriv√©e"
                print(f"   üìç Dernier segment : Sortie {last_toll.effective_name} ‚Üí Arriv√©e (√©vite {len(tolls_after)} p√©ages: {[t.effective_name for t in tolls_after]})")
                print(f"       üéØ Coordonn√©es : {start_coords} ‚Üí {end_coords}")
                print(f"       üí° Sortie optimale trouv√©e : {exit_junction['name']} √† {exit_junction['link_coordinates']}")
            else:
                # Fallback vers la m√©thode classique
                exit_coords = self.entrance_exit_finder.find_exit_coordinates(last_toll)
                segment_type = 'avoid_tolls'
                start_coords = exit_coords
                description = f"Sortie {last_toll.effective_name} vers arriv√©e"
                print(f"   üìç Dernier segment : Sortie {last_toll.effective_name} ‚Üí Arriv√©e (√©vite {len(tolls_after)} p√©ages: {[t.effective_name for t in tolls_after]} - fallback)")
        elif tolls_after:
            # Il faut √©viter les p√©ages suivants : utiliser la sortie du p√©age et route sans p√©ages
            exit_coords = self.entrance_exit_finder.find_exit_coordinates(last_toll)
            segment_type = 'avoid_tolls'
            start_coords = exit_coords
            description = f"Sortie {last_toll.effective_name} vers arriv√©e"
            print(f"   üìç Dernier segment : Sortie {last_toll.effective_name} ‚Üí Arriv√©e (√©vite {len(tolls_after)} p√©ages: {[t.effective_name for t in tolls_after]})")
        else:
            # Route normale du p√©age vers l'arriv√©e
            segment_type = 'normal'
            start_coords = last_toll.osm_coordinates
            description = f"{last_toll.effective_name} vers arriv√©e"
            print(f"   üìç Dernier segment : {last_toll.effective_name} ‚Üí Arriv√©e (route normale)")
        
        return {
            'segment_type': segment_type,
            'start': start_coords,
            'end': end_coords,
            'description': description
        }
    
    def build_toll_to_exit_segment(
        self, 
        toll: MatchedToll, 
        all_tolls: List[MatchedToll],
        route_coords: List[List[float]] = None
    ) -> Dict:
        """
        Construit le segment p√©age ‚Üí sortie optimale.
        
        Args:
            toll: P√©age utilis√©
            all_tolls: Tous les p√©ages sur la route
            route_coords: Coordonn√©es de la route de base
            
        Returns:
            Dict: Segment de route
        """
        tolls_after = self.toll_positioning.get_tolls_after(toll, all_tolls)
        
        if self.junction_analyzer and route_coords:
            # Trouver la sortie optimale apr√®s le p√©age et avant les p√©ages √† √©viter
            exit_junction = self.junction_analyzer.find_exit_after_toll(
                route_coords, toll, tolls_after
            )
            
            if exit_junction:
                # Segment du p√©age vers la sortie optimale (dans le bon sens)
                start_coords = toll.osm_coordinates
                end_coords = exit_junction['link_coordinates']
                
                print(f"   üìç Segment p√©age ‚Üí sortie : {toll.effective_name} ‚Üí {exit_junction['name']}")
                print(f"       üéØ Coordonn√©es : {start_coords} ‚Üí {end_coords}")
                
                return {
                    'segment_type': 'normal',  # Route normale jusqu'√† la sortie
                    'start': start_coords,
                    'end': end_coords,
                    'description': f"{toll.effective_name} vers sortie {exit_junction['name']}",
                    'exit_junction': exit_junction
                }
        
        # Fallback : utiliser la sortie calcul√©e classiquement
        exit_coords = self.entrance_exit_finder.find_exit_coordinates(toll)
        print(f"   üìç Segment p√©age ‚Üí sortie : {toll.effective_name} ‚Üí sortie (fallback)")
        
        return {
            'segment_type': 'normal',
            'start': toll.osm_coordinates,
            'end': exit_coords,
            'description': f"{toll.effective_name} vers sortie"
        }
    
    def build_exit_to_end_segment(
        self, 
        toll: MatchedToll, 
        end_coords: List[float],
        tolls_to_avoid: List[MatchedToll]
    ) -> Dict:
        """
        Construit le segment sortie ‚Üí arriv√©e en √©vitant les p√©ages.
        
        Args:
            toll: P√©age utilis√© (pour obtenir la sortie)
            end_coords: Coordonn√©es d'arriv√©e
            tolls_to_avoid: P√©ages √† √©viter
            
        Returns:
            Dict: Segment de route
        """
        # Utiliser la sortie trouv√©e dans le segment pr√©c√©dent ou calculer
        exit_coords = self.entrance_exit_finder.find_exit_coordinates(toll)
        
        print(f"   üìç Segment sortie ‚Üí arriv√©e : Sortie ‚Üí Arriv√©e (√©vite {len(tolls_to_avoid)} p√©ages)")
        print(f"       üéØ Coordonn√©es : {exit_coords} ‚Üí {end_coords}")
        
        return {
            'segment_type': 'avoid_tolls',  # Route sans p√©ages
            'start': exit_coords,
            'end': end_coords,
            'description': f"Sortie vers arriv√©e (√©vite p√©ages)"
        }
