"""
intelligent_segmentation_strategy_v4.py
--------------------------------------

Strat√©gie hybride compl√®te : utilisation des segments tollways d'ORS + optimisation de sortie en fallback.

Algorithme optimis√© :
1. Route de base + extraction des segments tollways avec coordonn√©es
2. Identifier p√©ages SUR la route  
3. S√©lectionner X p√©ages selon contraintes
4. **HYBRIDE** : Segmentation bas√©e sur tollways + optimisation cibl√©e
   - Cas normal : Utiliser segments gratuits naturels
   - Cas complexe : Optimiser sorties pour p√©ages probl√©matiques
5. Calcul des routes pour chaque segment
6. Assemblage final

R√®gles respect√©es :
- Fichier < 350 lignes
- Une responsabilit√© par classe/fonction
- R√©utilisation de code existant
- Organisation modulaire
"""

from typing import List, Dict, Optional, Tuple
from src.services.toll.new_segmentation.intelligent_segmentation_helpers import SegmentationSpecialCases, RouteUtils
from src.services.toll.new_segmentation.toll_matcher import TollMatcher, MatchedToll, convert_osm_tolls_to_matched_format
from src.services.toll.new_segmentation.toll_deduplicator import TollDeduplicator
from src.services.toll.new_segmentation.polyline_intersection import filter_tolls_on_route_strict
from src.services.toll.new_segmentation.exit_optimization import ExitOptimizationManager
from src.services.toll.new_segmentation.segment_route_calculator import SegmentRouteCalculator
from src.services.toll.new_segmentation.route_assembler import RouteAssembler
from src.services.toll.new_segmentation.hybrid_strategy import HybridSegmenter
from benchmark.performance_tracker import performance_tracker
from src.services.osm_data_cache import osm_data_cache


class IntelligentSegmentationStrategyV4:
    """
    Strat√©gie hybride tollways + optimisation de sortie.
    Version optimis√©e et modulaire.
    """
    
    def __init__(self, ors_service, osm_data_file: str = None):
        """Initialise la strat√©gie hybride optimis√©e."""
        self.ors = ors_service
        self.osm_parser = osm_data_cache._osm_parser
        self.toll_matcher = TollMatcher()
        
        # Modules sp√©cialis√©s
        self.exit_optimizer = ExitOptimizationManager(self.osm_parser, self.toll_matcher, self.ors)
        self.special_cases = SegmentationSpecialCases(ors_service)
        self.route_calculator = SegmentRouteCalculator(ors_service)
        self.route_assembler = RouteAssembler()
        self.hybrid_segmenter = HybridSegmenter(ors_service, self.exit_optimizer, self.osm_parser)
    
    def find_route_with_exact_tolls(
        self, 
        coordinates: List[List[float]], 
        target_tolls: int
    ) -> Optional[Dict]:
        """
        Trouve une route avec exactement le nombre de p√©ages demand√©.
        Utilise la strat√©gie hybride tollways + optimisation.
        """
        with performance_tracker.measure_operation("intelligent_segmentation_v4"):
            print(f"üß† Segmentation Hybride V4 : {target_tolls} p√©age(s) exact(s)")
            
            # CAS SP√âCIAL : 0 p√©age demand√©
            if target_tolls == 0:
                print("üö´ Cas sp√©cial : 0 p√©age demand√©")
                return self.special_cases.get_toll_free_route(coordinates)
            
            # √âtape 1 : Route de base + segments tollways
            base_route, tollways_data = self._get_base_route_with_tollways(coordinates)
            if not base_route:
                return None
            
            # √âtape 2 : Identifier p√©ages SUR la route
            route_coords = RouteUtils.extract_route_coordinates(base_route)
            tolls_on_route = self._identify_tolls_on_base_route(route_coords)
            
            # CAS SP√âCIAUX : optimisations directes
            if len(tolls_on_route) < target_tolls:
                print(f"‚ö†Ô∏è Pas assez de p√©ages ({len(tolls_on_route)} < {target_tolls})")
                return self.special_cases.format_base_route_as_result(base_route)
            
            if len(tolls_on_route) == target_tolls:
                print(f"‚úÖ Nombre exact de p√©ages trouv√©")
                return self.special_cases.format_base_route_as_result(base_route)
            
            # √âtape 3 : S√©lectionner p√©ages cibles
            selected_tolls = self._select_target_tolls(tolls_on_route, target_tolls)
            if not selected_tolls:
                return None
            
            # √âtape 4 : **HYBRIDE** Segmentation tollways + optimisation
            print("üèóÔ∏è √âtape 4 : Segmentation hybride tollways + optimisation...")
            segments = self.hybrid_segmenter.create_hybrid_segments(
                coordinates, tollways_data, tolls_on_route, selected_tolls, route_coords
            )
            
            if not segments:
                print("‚ùå √âchec segmentation hybride, fallback route de base")
                return self.special_cases.format_base_route_as_result(base_route)
            
            # √âtape 5 : Calcul des routes
            print("üìç √âtape 5 : Calcul des routes pour chaque segment...")
            segment_routes = self._calculate_hybrid_segments(segments)
            
            if not segment_routes:
                print("‚ùå √âchec calcul segments, fallback route de base")
                return self.special_cases.format_base_route_as_result(base_route)
            
            

            # √âtape 6 : Assemblage final
            print("üîß √âtape 6 : Assemblage final...")
            return self.route_assembler.assemble_final_route_multi(
                segment_routes, target_tolls, selected_tolls
            )
    
    def _get_base_route_with_tollways(self, coordinates: List[List[float]]) -> Tuple[Optional[Dict], Optional[Dict]]:
        """√âtape 1 : Route de base + extraction des segments tollways avec coordonn√©es."""
        try:
            print(f"üõ£Ô∏è √âtape 1 : Route de base + tollways {coordinates[0]} ‚Üí {coordinates[1]}")
            base_route = self.ors.get_base_route(coordinates, include_tollways=True)
            
            if not base_route:
                return None, None
            
            # Extraire les donn√©es tollways avec coordonn√©es
            tollways_data = self._extract_tollways_with_coordinates(base_route)
            print(f"   üìä {len(tollways_data.get('segments', []))} segments tollways avec coordonn√©es")
            
            return base_route, tollways_data
            
        except Exception as e:
            print(f"‚ùå Erreur route de base : {e}")
            return None, None
    
    def _extract_tollways_with_coordinates(self, base_route: Dict) -> Dict:
        """Extrait les segments tollways avec leurs coordonn√©es de d√©but/fin."""
        try:
            features = base_route.get('features', [])
            if not features:
                return {'segments': []}
            
            properties = features[0].get('properties', {})
            extras = properties.get('extras', {})
            tollways = extras.get('tollways', {})
            
            if 'values' not in tollways:
                return {'segments': []}
            
            # R√©cup√©rer les coordonn√©es de la route
            route_coords = RouteUtils.extract_route_coordinates(base_route)
            
            # Transformer en format avec coordonn√©es
            segments = []
            for value in tollways['values']:
                if len(value) >= 3:
                    start_waypoint = value[0]
                    end_waypoint = value[1]
                    is_toll = value[2] == 1
                    
                    # R√©cup√©rer les coordonn√©es correspondantes
                    start_coord = route_coords[start_waypoint] if start_waypoint < len(route_coords) else None
                    end_coord = route_coords[end_waypoint] if end_waypoint < len(route_coords) else None
                    
                    segments.append({
                        'start_waypoint': start_waypoint,
                        'end_waypoint': end_waypoint,
                        'start_coord': start_coord,
                        'end_coord': end_coord,
                        'is_toll': is_toll,
                        'is_free': not is_toll,
                        'coordinates': route_coords[start_waypoint:end_waypoint + 1] if end_waypoint < len(route_coords) else []
                    })
            
            return {
                'segments': segments,
                'route_coords': route_coords
            }
            
        except Exception as e:
            print(f"‚ö†Ô∏è Erreur extraction tollways : {e}")
            return {'segments': []}
    
    def _identify_tolls_on_base_route(self, route_coords: List[List[float]]) -> List[MatchedToll]:
        """√âtape 2 : Identifier p√©ages SUR la route (r√©utilise la logique √©prouv√©e)."""
        print("üîç √âtape 2 : Identification des p√©ages sur la route...")
        
        # Recherche large + stricte (logique V2/V3 √©prouv√©e)
        osm_tolls_large = self.osm_parser.find_tolls_near_route(route_coords, max_distance_km=0.5)
        print(f"   üìç D√©tection large : {len(osm_tolls_large)} p√©ages dans 500m")
        
        tolls_on_route_strict = filter_tolls_on_route_strict(
            osm_tolls_large, route_coords, max_distance_m=1, coordinate_attr='coordinates', verbose=True
        )
        
        osm_tolls_strict = [toll_data[0] for toll_data in tolls_on_route_strict]
        print(f"   üéØ {len(osm_tolls_strict)} p√©ages strictement sur la route")
        
        # Convertir, matcher, d√©dupliquer, ordonner (logique √©prouv√©e)
        osm_tolls_formatted = convert_osm_tolls_to_matched_format(osm_tolls_strict)
        matched_tolls = self.toll_matcher.match_osm_tolls_with_csv(osm_tolls_formatted, max_distance_km=2.0)
        deduplicated_tolls = TollDeduplicator.deduplicate_tolls_by_proximity(matched_tolls, route_coords)
        ordered_tolls = TollDeduplicator.sort_tolls_by_route_position(deduplicated_tolls, route_coords)
        
        return ordered_tolls
    
    def _select_target_tolls(self, available_tolls: List[MatchedToll], target_count: int) -> List[MatchedToll]:
        """√âtape 3 : S√©lection de p√©ages (r√©utilise la logique V2/V3)."""
        print(f"üéØ √âtape 3 : S√©lection de {target_count} p√©age(s)...")
        
        if target_count > len(available_tolls):
            return []
        
        # S√©parer par syst√®me
        open_tolls = [t for t in available_tolls if t.is_open_system]
        closed_tolls = [t for t in available_tolls if not t.is_open_system]
        
        # Logique de s√©lection √©prouv√©e
        selected_tolls = []
        
        # Prioriser ferm√©s par paires
        if len(closed_tolls) >= 2:
            pairs_available = len(closed_tolls) // 2
            pairs_needed = min(pairs_available, target_count // 2)
            if target_count % 2 == 1 and pairs_available > pairs_needed:
                pairs_needed += 1
            selected_tolls.extend(closed_tolls[:pairs_needed * 2])
        
        # Compl√©ter avec ouverts
        remaining = target_count - len(selected_tolls)
        if remaining > 0:
            selected_tolls.extend(open_tolls[:remaining])
        
        final_selected = selected_tolls[:target_count]
        
        # V√©rifier contrainte (pas de ferm√© seul)
        closed_count = sum(1 for t in final_selected if not t.is_open_system)
        if closed_count == 1:
            final_selected = open_tolls[:target_count]
        
        print(f"   ‚úÖ {len(final_selected)} p√©ages s√©lectionn√©s")
        return final_selected
    
    def _calculate_hybrid_segments(self, segments: List[Dict]) -> List[Dict]:
        """Calcule les routes pour les segments hybrides."""
        print(f"üî¢ Calcul de {len(segments)} segments hybrides...")
        
        segment_routes = []
        
        for i, segment in enumerate(segments):
            print(f"\nüìç Segment {i+1}/{len(segments)}")
            
            segment_type = segment.get('type', 'normal')
            start_coord = segment['start']
            end_coord = segment['end']
            description = segment.get('description', f'Segment {i+1}')
            
            print(f"üîÑ Calcul segment : {description}")
            print(f"   üìç D√©part: {start_coord}")
            print(f"   üìç Arriv√©e: {end_coord}")
            
            # Debug : Afficher les cl√©s et coordonn√©es des segments
            for idx, seg in enumerate(segments):
                start = seg.get('start')
                end = seg.get('end')
                print(f"   [DEBUG] Segment {idx+1}: keys={list(seg.keys())}, start={start}, end={end}")
            
            # Calculer selon le type de segment
            if segment_type == 'toll_free':
                route = self.ors.get_base_route([start_coord, end_coord], include_tollways=False)
                print(f"   üö´ Route sans p√©age calcul√©e")
            else:
                route = self.ors.get_base_route([start_coord, end_coord], include_tollways=True)
                print(f"   üõ£Ô∏è Route normale calcul√©e")
            
            if route:
                segment_routes.append({
                    'segment_info': segment,
                    'route': route,
                    'index': i
                })
                print(f"   ‚úÖ Segment calcul√© avec succ√®s")
            else:
                print(f"   ‚ùå √âchec calcul segment {i+1}")
                return []
        
        print(f"‚úÖ {len(segment_routes)} segments calcul√©s avec succ√®s")
        return segment_routes
