"""
Selection Analyzer
==================

Analyse les s√©lections de p√©ages pour optimisation et pr√©paration √† la segmentation.
Transforme les p√©ages s√©lectionn√©s en √©l√©ments optimis√©s (TollBoothStation, CompleteMotorwayLink).
"""

from typing import List, Dict, Tuple, Optional
import sys
import os
sys.path.append(os.path.join(os.path.dirname(__file__), '..', '..', '..', '..'))

from src.cache.v2.models.toll_booth_station import TollBoothStation
from src.cache.v2.models.complete_motorway_link import CompleteMotorwayLink, LinkType
from ..utils.cache_accessor import CacheAccessor


class SelectionAnalyzer:
    """
    Analyseur de s√©lections pour optimisation.
    Transforme les p√©ages s√©lectionn√©s en √©l√©ments optimis√©s.
    """
    
    def __init__(self):
        """Initialise l'analyseur."""
        # Utiliser CacheAccessor au lieu de cr√©er un nouveau cache manager
        print("üîç Selection Analyzer initialis√© avec CacheAccessor")
        
    def analyze_selection_for_optimization(
        self, 
        selection_result: Dict, 
        route_coordinates: List[List[float]]
    ) -> Dict:
        """
        Analyse la s√©lection et retourne les √©l√©ments optimis√©s.
        
        Args:
            selection_result: R√©sultat de s√©lection initial
            route_coordinates: Coordonn√©es de route [start, end]
            
        Returns:
            R√©sultat avec √©l√©ments optimis√©s (TollBoothStation, CompleteMotorwayLink)
        """
        if not selection_result.get('selection_valid'):
            return selection_result
            
        print("üîç Analyse pour optimisation...")
        
        selected_tolls = selection_result['selected_tolls']
        optimized_elements = []
        
        # Analyser chaque p√©age s√©lectionn√©
        for toll in selected_tolls:
            optimized_element = self._optimize_toll_element(toll, route_coordinates)
            if optimized_element:
                optimized_elements.append(optimized_element)
        
        # Mettre √† jour le r√©sultat
        selection_result['selected_tolls'] = optimized_elements
        selection_result['optimization_applied'] = True
        selection_result['elements_optimized'] = len(optimized_elements)
        
        print(f"   ‚úÖ {len(optimized_elements)} √©l√©ments optimis√©s")
        return selection_result
    
    def _optimize_toll_element(
        self, 
        toll: Dict, 
        route_coordinates: List[List[float]]
    ) -> Optional[object]:
        """
        Optimise un √©l√©ment p√©age en le transformant en objet cache V2.
        
        Args:
            toll: √âl√©ment p√©age √† optimiser
            route_coordinates: Coordonn√©es de route
            
        Returns:
            √âl√©ment optimis√© (TollBoothStation ou CompleteMotorwayLink)
        """
        toll_type = toll.get('toll_type')
        toll_name = toll.get('name', 'Inconnu')
        
        print(f"   üîß Optimisation de {toll_name} ({toll_type})")
        
        result = None
        if toll_type == 'ouvert':
            result = self._get_toll_booth_station(toll)
            print(f"       ‚Üí Recherche TollBoothStation: {'‚úÖ Trouv√©' if result else '‚ùå Non trouv√©'}")
        elif toll_type == 'ferm√©':
            result = self._get_optimized_motorway_link(toll, route_coordinates)
            print(f"       ‚Üí Recherche MotorwayLink: {'‚úÖ Trouv√©' if result else '‚ùå Non trouv√©'}")
        else:
            # Fallback : essayer de trouver l'√©l√©ment correspondant
            result = self._find_best_match(toll, route_coordinates)
            print(f"       ‚Üí Recherche fallback: {'‚úÖ Trouv√©' if result else '‚ùå Non trouv√©'}")
        
        return result
    
    def _get_toll_booth_station(self, toll: Dict) -> Optional[TollBoothStation]:
        """R√©cup√®re la TollBoothStation correspondante."""
        try:
            # Utiliser CacheAccessor pour r√©cup√©rer les p√©ages
            toll_stations = CacheAccessor.get_toll_stations()
            
            osm_id = toll.get('osm_id')
            if osm_id:
                # Recherche par OSM ID
                for station in toll_stations:
                    if station.osm_id == osm_id:
                        return station
            
            # Recherche par coordonn√©es si pas d'OSM ID
            coordinates = toll.get('coordinates', [])
            if coordinates:
                # Recherche simplifi√©e dans tous les p√©ages
                min_distance = float('inf')
                closest_toll = None
                
                for station in toll_stations:
                    distance = self._calculate_distance(station.get_coordinates(), coordinates)
                    if distance < min_distance:
                        min_distance = distance
                        closest_toll = station
                
                # Retourner le plus proche si dans un rayon raisonnable (500m)
                if closest_toll and min_distance < 0.5:
                    return closest_toll
                
        except Exception as e:
            print(f"   ‚ö†Ô∏è Erreur r√©cup√©ration TollBoothStation : {e}")
            
        return None
    
    def _get_optimized_motorway_link(
        self, 
        toll: Dict, 
        route_coordinates: List[List[float]]
    ) -> Optional[CompleteMotorwayLink]:
        """
        R√©cup√®re le lien autoroutier optimis√© pour un p√©age ferm√©.
        
        Args:
            toll: P√©age ferm√©
            route_coordinates: Coordonn√©es de route
            
        Returns:
            CompleteMotorwayLink optimis√© (entr√©e ou sortie)
        """
        try:
            # R√©cup√©rer les liens d'entr√©e et de sortie proches
            toll_coords = toll.get('coordinates', [])
            if not toll_coords:
                return None
            
            # Utiliser CacheAccessor pour r√©cup√©rer les liens
            entry_links = CacheAccessor.get_entry_links()
            exit_links = CacheAccessor.get_exit_links()
            
            # Trouver les liens proches
            nearby_entries = []
            nearby_exits = []
            
            for link in entry_links:
                distance = self._calculate_distance(link.get_start_point(), toll_coords)
                if distance < 2.0:  # Rayon de 2km
                    nearby_entries.append(link)
            
            for link in exit_links:
                distance = self._calculate_distance(link.get_end_point(), toll_coords)
                if distance < 2.0:  # Rayon de 2km
                    nearby_exits.append(link)
            
            print(f"   üîç Liens trouv√©s pr√®s de {toll.get('name', 'Inconnu')}: {len(nearby_entries)} entr√©es, {len(nearby_exits)} sorties")
            
            # Choisir le meilleur lien selon la position sur la route
            best_link = self._choose_best_link_for_route(
                nearby_entries, nearby_exits, route_coordinates, toll_coords
            )
            
            return best_link
            
        except Exception as e:
            print(f"   ‚ö†Ô∏è Erreur optimisation lien autoroutier : {e}")
            
        return None
    
    def _choose_best_link_for_route(
        self, 
        entries: List[CompleteMotorwayLink], 
        exits: List[CompleteMotorwayLink],
        route_coordinates: List[List[float]], 
        toll_coords: List[float]
    ) -> Optional[CompleteMotorwayLink]:
        """
        Choisit le meilleur lien autoroutier selon la position sur la route.
        
        Args:
            entries: Liens d'entr√©e disponibles
            exits: Liens de sortie disponibles
            route_coordinates: Coordonn√©es de route [start, end]
            toll_coords: Coordonn√©es du p√©age
            
        Returns:
            Meilleur lien autoroutier
        """
        start_point = route_coordinates[0]
        end_point = route_coordinates[1]
        
        # Calculer la distance relative du p√©age sur la route
        toll_distance_from_start = self._calculate_distance(start_point, toll_coords)
        toll_distance_from_end = self._calculate_distance(end_point, toll_coords)
        total_route_distance = self._calculate_distance(start_point, end_point)
        
        # Position relative (0 = d√©but, 1 = fin)
        relative_position = toll_distance_from_start / total_route_distance if total_route_distance > 0 else 0.5
        
        # Choix de strat√©gie selon la position
        if relative_position < 0.3:
            # D√©but de route ‚Üí pr√©f√©rer entr√©e
            return self._get_best_entry(entries, toll_coords)
        elif relative_position > 0.7:
            # Fin de route ‚Üí pr√©f√©rer sortie
            return self._get_best_exit(exits, toll_coords)
        else:
            # Milieu de route ‚Üí choisir le plus proche
            best_entry = self._get_best_entry(entries, toll_coords)
            best_exit = self._get_best_exit(exits, toll_coords)
            
            if not best_entry:
                return best_exit
            if not best_exit:
                return best_entry
                
            # Comparer les distances
            entry_distance = self._calculate_distance(best_entry.get_start_point(), toll_coords)
            exit_distance = self._calculate_distance(best_exit.get_end_point(), toll_coords)
            
            return best_entry if entry_distance <= exit_distance else best_exit
    
    def _get_best_entry(self, entries: List[CompleteMotorwayLink], toll_coords: List[float]) -> Optional[CompleteMotorwayLink]:
        """R√©cup√®re la meilleure entr√©e."""
        if not entries:
            return None
            
        # Trier par distance
        entries_with_distance = [
            (entry, self._calculate_distance(entry.get_start_point(), toll_coords))
            for entry in entries
        ]
        entries_with_distance.sort(key=lambda x: x[1])
        
        return entries_with_distance[0][0]
    
    def _get_best_exit(self, exits: List[CompleteMotorwayLink], toll_coords: List[float]) -> Optional[CompleteMotorwayLink]:
        """R√©cup√®re la meilleure sortie."""
        if not exits:
            return None
            
        # Trier par distance
        exits_with_distance = [
            (exit_link, self._calculate_distance(exit_link.get_end_point(), toll_coords))
            for exit_link in exits
        ]
        exits_with_distance.sort(key=lambda x: x[1])
        
        return exits_with_distance[0][0]
    
    def _find_best_match(
        self, 
        toll: Dict, 
        route_coordinates: List[List[float]]
    ) -> Optional[object]:
        """Trouve le meilleur √©l√©ment correspondant par recherche g√©n√©rale."""
        coordinates = toll.get('coordinates', [])
        if not coordinates:
            return None
            
        # Essayer d'abord TollBoothStation
        toll_booth = self._find_closest_toll_booth(coordinates)
        if toll_booth:
            return toll_booth
            
        # Sinon, chercher un lien autoroutier
        closest_link = self._find_closest_motorway_link(coordinates)
        if closest_link:
            return closest_link
            
        return None
    
    def _find_closest_toll_booth(self, coordinates: List[float]) -> Optional[TollBoothStation]:
        """Trouve le p√©age le plus proche."""
        min_distance = float('inf')
        closest_toll = None
        
        toll_stations = CacheAccessor.get_toll_stations()
        for toll_booth in toll_stations:
            distance = self._calculate_distance(toll_booth.get_coordinates(), coordinates)
            if distance < min_distance:
                min_distance = distance
                closest_toll = toll_booth
        
        # Retourner si dans un rayon raisonnable (5km)
        return closest_toll if min_distance < 5.0 else None
    
    def _find_closest_motorway_link(self, coordinates: List[float]) -> Optional[CompleteMotorwayLink]:
        """Trouve le lien autoroutier le plus proche."""
        min_distance = float('inf')
        closest_link = None
        
        complete_links = CacheAccessor.get_complete_motorway_links()
        for link in complete_links:
            distance = self._calculate_distance(link.get_start_point(), coordinates)
            if distance < min_distance:
                min_distance = distance
                closest_link = link
        
        # Retourner si dans un rayon raisonnable (1km)
        return closest_link if min_distance < 1.0 else None
    
    def _calculate_distance(self, point1: List[float], point2: List[float]) -> float:
        """
        Calcule la distance approximative entre deux points.
        
        Args:
            point1: Premier point [lon, lat]
            point2: Deuxi√®me point [lon, lat]
            
        Returns:
            Distance en kilom√®tres (approximative)
        """
        if not point1 or not point2 or len(point1) < 2 or len(point2) < 2:
            return float('inf')
            
        # Distance euclidienne simple (approximation)
        dx = point1[0] - point2[0]
        dy = point1[1] - point2[1]
        
        # Conversion approximative en km (1 degr√© ‚âà 111 km)
        return ((dx * dx + dy * dy) ** 0.5) * 111
